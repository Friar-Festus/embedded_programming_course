# Embedded Programming Course

In which I go through [Miro Samek's Course](https://www.state-machine.com/video-course/) using the EK-TM4C1294XL development board and Code Composer Studio (CCS) with GCC. CCS is currently (July 2021) at v10.3.1.

## Motivation

I have gone through the course previously, up to and including the RTOS section, using a TM4C123G dev board and the dev tools used in the videos, e.g. IAR Embedded Workbench for ARM (EWARM). There are 10 more videos in the series since the last time I went through. I figured I'd go through the course from the start as it's never a bad idea to get a refresher on the fundamentals. 

Much of the nitty-gritty of e.g. GPIO manipulation is hidden behind vendor-provided hardware abstraction layers. This is generally a good thing, but it's also good to know what to look for when things are not working as expected. And sometimes direct register manipulation is necessary. I'm looking at you, pull configuration registers.

## CCS on Linux

I'm using a Windows 10 machine for most of this course, but set up CCS on a Linux machine as well, as that is the daily driver in my home office.

Note that the following install scripts must be run using `sudo` to allow the In-Circuit Debugger to work (substitute current CCS install folder as necessary):

- `~/ti/ccs1031/ccs/install_scripts/install_drivers.sh`
- `~/ti/ccs1031/ccs/install_scripts/ti_permissions_install.sh`

I had to reboot to get the changes to take effect and flash the dev board.

## The Code

Most of the code contained in this repository will be identical to that accessible via the course link above. However, the TM4C1294 dev board has four single-color LEDs vs an RGB LED, so the ports/bits used will be slightly different.

Note that the assembly code generated by CCS may not exactly match the code shown in the videos, due to use of a different IDE/compiler.

In the lesson descriptions below, I will mainly point out differences when using CCS, or any potential "gotchas".

### Lesson 0 - Getting Started

Covers:
- Discussion of the ARM Cortex family
- Installation of IAR EWARM
  - Again, I am using [TI's Code Composer Studio](https://www.ti.com/tool/CCSTUDIO-SAFETY) integrated development environment (IDE)
  - The CCS link is for the "safety" version, select the Tiva family for inclusion during installation
  - Mr. Samek covers installation of CCS in video #19 [GNU-ARM and Eclipse](https://youtu.be/BBF3ZMi8WK4)
- Ordering of the development board
  - IAR EWARM (at least the older version) includes a simulator that will get one through the first few lessons, but eventually real hardware will be needed
  - The TM4C123G Launchpad is equivalent to the board recommended for the course
  - I am using the [EK-TM4C1294XL](https://www.ti.com/lit/ug/spmu365c/spmu365c.pdf) board, as I had one on hand, and I wanted to use something different to force me to look at the [datasheet](https://www.ti.com/lit/ds/symlink/tm4c1294ncpdt.pdf)

### Lesson 1 - Counting

Note that the default optimization in CCS will prevent the counter from working properly. Set compiler optimization to zero for now. The `volatile` keyword will be covered in Lesson 5.

### Lesson 2 - Flow of Control

<u>**Copying Projects:**</u> This is slightly more complicated when using CCS than it is with EWARM. The procedure goes something like this, assuming Win10:
- Navigate to the workspace folder in File Explorer
- Copy the `lesson1` folder and rename it to `lesson2`
  - I've been copying the last lesson to the next one, i.e. lesson[x] to lesson[x+1]
- Open the new folder, then open `.cproject` and `.project` and change all occurrences of e.g. "lesson1" to "lesson2" in each file
- Save the modified `.cproject` and `.project`
- With the overall workspace open in CCS, click <u>F</u>ile &rarr; Import... 
- Select "CCS Projects" &rarr; <u>N</u>ext >
- Click B<u>r</u>owse... next to Select s<u>e</u>arch-directory:
- You should already be in the correct folder - if not, navigate to the workspace folder
- Select the "new" project, then click <u>F</u>inish

### Lesson 3 - Variables and Pointers

### Lesson 4 - Blinking the LED

This is where the code diverges just a bit, due to the differences in the LEDs included on the different boards. Since I couldn't just blindly follow the video to get the register memory locations, I was forced to go to the datasheet. Also, two different ports are used for the four LEDs on the TM4C1294 board, increasing the difficulty level *slightly*. Check the dev board [user manual](https://www.ti.com/lit/ug/spmu365c/spmu365c.pdf) for LED port assignments.

Note the address masking - it is explained better in a later video, where 0x3FC is added to the base port address.

### Lesson 5 - Preprocessor and the Volatile Keyword in C

The required header file `tm4c1294ncpdt.h` was not included with the CCS install. I retrieved a copy from:

>http://users.ece.utexas.edu/~valvano/arm/

Note that this version of the file has been modified to use only the _AHB_ (Advanced High-Performance Bus) memory locations, which are discussed in Lesson 7. All GPIO ports on the TM4C1294 only uses the AHB, and macros `GPIO_PORTF_AHB_DATA_R` and `GPIO_PORTF_DATA_R` map to the same address in the original header. The TM4C123 has ports that also use the ABP bus, so the two macros map to different base addresses.

If you simply place the header file in the same folder as `main.c`, the compiler will find it easily. I like to put headers in an `include` folder, which requires modifying the project properties to add that folder to the places where the compiler looks for includes:

Project &rarr; Properties &rarr; CCS Build &rarr; GNU Compiler &rarr; Directories

### Lesson 6 - Bit-Wise Operators in C

(Re)learned something:
- Logical shift (unsigned values) - Right shifts shift in zeros from the left
- Arithmetic shift (signed values) - Right shifts shift in ones from the left, which makes sense to keep the negative value and two's complement form

### Lesson 7 - Arrays and Pointer Arithmetic

### Lesson 8 - Functions and the Stack

Note that one million (1000000) can also be written as `1e6`. I'm lazy and this method is easier than counting zeros for large values. Similarly 500000 &rarr; 5e5.

### Lesson 9 - Modules, Recursion, AAPCS

AAPCS: ARM Application Procedure Call Standard 

Strayed from the video again, to organize source files (*.c) into a `source` folder. `delay.h` was placed in the `include` foler.

It is not necessary to explicitly add new files to the project when using CCS (Eclipse).

### Lesson 10 - Stack Overflow and Other Pitfalls of Functions

Unfortunately, CCS does not have a nice stack viewer. There is a "Stack Usage" view available when using the TI compiler. I tried it briefly and was unable to actually see anything useful, but I did not try too hard as I'm still trying to use the GCC tools exclusively.

It's still possible to use the Memory Browser to view the stack by examining the region pointed to by the Stack Pointer (SP) register. The "call stack" is shown in the "Debug" window, not quite as nicely as shown in the video using IAR EWARM, but it's there.

Newer versions of CCS do not appear to have a simple way to set heap and stack size in the linker file. They can be set by adding `-heap=0` and/or `-stack=1024` to the "Miscellaneous" flags in the linker settings.